<!doctype html>
<html>
<head>
    <base href="/">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="author" content="">

<meta name="description" content="">

<title>First</title>
<meta name="generator" content="Hugo 0.46" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/pojoaque.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
<link  href="https://urlve.github.io//css/theme.min.css" rel="stylesheet" type="text/css">

</head>
<body>
<div class="page-container container-fluid">
<div class="col-md-3 menu">
    <nav class="col-md-3">
    <h3 class="home-link"><a href="https://urlve.github.io/">Root</a></h3>
    <div id="last-posts" class="open">
        <h3 data-open="last-posts">My New Hugo Site - Most recent posts</h3>
        <ul>
            
            <li><a href="https://urlve.github.io/post/test/">Test</a></li>
            
            <li><a href="https://urlve.github.io/post/first/">First</a></li>
            
            <li><a href="https://urlve.github.io/about/">About</a></li>
            
        </ul>
    </div>

    

    
</nav>

</div>
<div class="col-md-9 content">

<h1>First</h1>
<h4>Published 08-16-2018 10:51:21</h4>

<a href="https://twitter.com/share" class="twitter-share-button" data-via="kendo5731"></a>
<script>!function (d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
    if (!d.getElementById(id)) {
        js = d.createElement(s);
        js.id = id;
        js.src = p + '://platform.twitter.com/widgets.js';
        fjs.parentNode.insertBefore(js, fjs);
    }
}(document, 'script', 'twitter-wjs');</script>

<div class="fb-share-button" data-href="https://urlve.github.io/post/first/" data-layout="button"></div>
<div id="fb-root"></div>
<script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en-US/sdk.js#xfbml=1&version=v2.5";
    fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<article>
    

<h1 id="1995">1995</h1>

<h2 id="题目一-题目大意">题目一-题目大意</h2>

<p>给出一个算式，根据给出的数字求这个算式中的未知数字。</p>

<h2 id="考察算法">考察算法</h2>

<p>暴力枚举。</p>

<h2 id="算法一">算法一</h2>

<h3 id="思路">思路：</h3>

<p>暴力枚举除数和被除数，算出其它数字，再判断是否满足算式的条件。</p>

<h3 id="时间复杂度分析">时间复杂度分析：</h3>

<p>$O(M * N)$，$M \leq 100,N \leq 10000$。</p>

<h3 id="期望得分">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
	for (int i = 10;i &lt;= 99;i++)
	{
		for (int j = 1000;j &lt;= 9999;j++)
		{
			int k = i * 8;
			if (k &gt;= 100) continue;
			int x = j / 100;
			int y = x - k;
			if (y &lt; 1 || y &gt; 9) continue;
			int m = y * 100 + j % 100;
			int n = i * 9;
			if (n &lt; 100) continue;
			if (m - n != 1) continue;
			printf(&quot;         809\n&quot;);  
			printf(&quot;   ------------\n&quot;);  
			printf(&quot;%d)     %d\n&quot;,i,j);  
			printf(&quot;        %d\n&quot;,k);  
			printf(&quot;   ------------\n&quot;);  
			printf(&quot;         %d\n&quot;,m);  
			printf(&quot;         %d\n&quot;,n);  
			printf(&quot;   ------------\n&quot;);  
			printf(&quot;           1\n&quot;);
		}
	}
	return 0;
}
</code></pre>

<h2 id="题目二-题目大意">题目二-题目大意</h2>

<p>再一个$N * N$的方阵中，填入$1-N * N$共$N * N$个数字，并且满足这些数字是呈蛇形排列的。</p>

<h2 id="考察算法-1">考察算法</h2>

<p>模拟。</p>

<h2 id="算法一-1">算法一</h2>

<h3 id="思路-1">思路：</h3>

<p>每一步填当前的格子，从$(1,n)$开始从上往下填数，然后从右往左，再从下往上，最后从左往右，循环直到填了$N * N$个数字。</p>

<h3 id="时间复杂度分析-1">时间复杂度分析：</h3>

<p>$O(N*N)$。</p>

<h3 id="期望得分-1">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码-1">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 105;

int a[N][N];

int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	int x = 1,y = n,cnt = 0;
	while (1)
	{
		while (x &lt;= n)
		{
			a[x][y] = ++cnt;
			if (x == n || a[x+1][y]) break;
			x++;
		}
		if (cnt &gt;= n * n) break;
		y--;
		while (y &gt;= 1)
		{
			a[x][y] = ++cnt;
			if (y == 1 || a[x][y-1]) break;
			y--;
		}
		if (cnt &gt;= n * n) break;
		x--;
		while (x &gt;= 1)
		{
			a[x][y] = ++cnt;
			if (x == 1 || a[x-1][y]) break;
			x--;
		}
		if (cnt &gt;= n * n) break;
		y++;
		while (y &lt;= n)
		{
			a[x][y] = ++cnt;
			if (y == n || a[x][y+1]) break;
			y++;
		}
		if (cnt &gt;= n * n) break;
		x++;
	}
	for (int i = 1;i &lt;= n;i++)
	{
		for (int j = 1;j &lt;= n;j++)
		{
			printf(&quot;%3d%c&quot;,a[i][j],j == n ? '\n' : ' ');
		}
	}
	return 0;
}
</code></pre>

<h2 id="算法二">算法二</h2>

<h3 id="思路-2">思路：</h3>

<p>每一步填下一个格子，先把$(1,n)$填了，然后从右往左，再从下往上，最后从左往右，循环直到填了$N * N$个数字。</p>

<h3 id="时间复杂度分析-2">时间复杂度分析：</h3>

<p>$O(N*N)$。</p>

<h3 id="期望得分-2">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码-2">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
const int N = 105; 
int a[N][N];  
	
int main()  
{  
	int n,cnt = 1;
	int x,y;  
	scanf(&quot;%d&quot;,&amp;n);   
	x = 0,y = n-1;  
	a[x][y] = 1;  
		
	while(cnt &lt; n*n)  
	{  
		 while(x+1&lt;n &amp;&amp; !a[x+1][y]) a[++x][y] = ++cnt;   
		 while(y-1&gt;=0  &amp;&amp; !a[x][y-1]) a[x][--y] = ++cnt;  
		 while(x-1&gt;=0  &amp;&amp; !a[x-1][y]) a[--x][y] = ++cnt;  
		 while(y+1&lt;n &amp;&amp; !a[x][y+1]) a[x][++y] = ++cnt;       
	}  
		
	for (int i = 0;i &lt; n;i++)
	{
		for (int j = 0;j &lt; n;j++)
		{
			printf(&quot;%3d%c&quot;,a[i][j],j == n - 1 ? '\n' : ' ');
		}
	}
	return 0;
}
</code></pre>

<h2 id="题目三-题目大意">题目三-题目大意</h2>

<p>一个数字的二进制表示中，如果1的数量大于0的数量，那么这个数字就是A类数字，否则就是B类数字。求$[1,1000]$这个区间内A类数字和B类数字的数量。</p>

<h2 id="考察算法-2">考察算法</h2>

<p>位运算。</p>

<h2 id="算法一-2">算法一</h2>

<h3 id="思路-3">思路：</h3>

<p>对于每一个数字，用位运算分别计算它二进制表示的0和1的数量即可。</p>

<h3 id="时间复杂度分析-3">时间复杂度分析：</h3>

<p>$O(N*logN)$，$N \leq 1000$。</p>

<h3 id="期望得分-3">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码-3">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
	int a = 0,b = 0;
	for (int i = 1;i &lt;= 1000;i++)
	{
		int one = 0,zero = 0;
		int tmp = i;
		while (tmp)
		{
			if (tmp &amp; 1) one++;
			else zero++;
			tmp &gt;&gt;= 1;
		}
		if (one &gt; zero) a++;
		else b++;
	}
	printf(&quot;A:%d B:%d\n&quot;,a,b);
	return 0;
}
</code></pre>

<h2 id="题目四-题目大意">题目四-题目大意</h2>

<p>一个数组$a$包含$0$到$n-1$共$n$个元素，定义$b[0] = 0$，$b[i]$为$a[0]$到$a[i-1]$中小于$a[i]$的元素的个数。</p>

<p>如果输入的是a数组，那么求b数组；</p>

<p>如果输入的是b数组，那么求a数组。</p>

<h2 id="考察算法-3">考察算法</h2>

<p>模拟，暴力枚举。</p>

<h2 id="算法一-3">算法一</h2>

<h3 id="思路-4">思路：</h3>

<p>如果给出的是a数组，那么直接两重循环得出b数组。</p>

<p>如果给出的是b数组，那么就从最后一个数字开始寻找，每次首先枚举这个数，再枚举统计比这个数小的并且还未得出的数字的个数，如果这个数量等于当前的b[i]，那么就找到了a[i]。</p>

<h3 id="时间复杂度分析-4">时间复杂度分析：</h3>

<p>寻找a数组：$O(N^2)$；寻找b数组：$O(N^3)$。</p>

<h3 id="期望得分-4">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码-4">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 105;
int a[N],b[N];
bool vis[N];

int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	char ch;
	scanf(&quot; %c&quot;,&amp;ch);
	if (ch == 'A')
	{
		getchar();
		getchar();
		for (int i = 0;i &lt; n;i++)
		{
			scanf(&quot;%d%c&quot;,&amp;a[i],&amp;ch);
		}
		b[0] = 0;
		for (int i = 1;i &lt; n;i++)
		{
			int cnt = 0;
			for (int j = 0;j &lt; i;j++)
			{
				if (a[j] &lt; a[i]) cnt++;
			}
			b[i] = cnt;
		}
		printf(&quot;B=(&quot;);
		for (int i = 0;i &lt; n;i++)
		{
			printf(&quot;%d%c&quot;,b[i],i == n - 1 ? ')' : ',');
		}
	}
	else
	{
		getchar();
		getchar();
		for (int i = 0;i &lt; n;i++)
		{
			scanf(&quot;%d%c&quot;,&amp;b[i],&amp;ch);
		}
		for (int i = n - 1;i &gt;= 0;i--)
		{
			for (int j = 0;j &lt; n;j++)
			{
				if (!vis[j])
				{
					int cnt = 0;
					for (int k = 0;k &lt; n;k++)
					{
						if (!vis[k] &amp;&amp; k &lt; j) cnt++;
					}
					if (cnt == b[i])
					{
						a[i] = j;
						vis[j] = 1;
						break;
					} 
				}
			}
		}
		printf(&quot;A=(&quot;);
		for (int i = 0;i &lt; n;i++)
		{
			printf(&quot;%d%c&quot;,a[i],i == n - 1 ? ')' : ',');
		}
	}
	return 0;
}
</code></pre>

<h2 id="算法二-1">算法二</h2>

<h3 id="思路-5">思路：</h3>

<p>找a数组与算法一相同；</p>

<p>寻找b数组的时候，因为第一层循环是从后往前枚举的，所以已经找到了的数字，对于当前寻找的数字是没有任何贡献的，那些还未找到的数字，才会对比当前数字小的个数有贡献。所以在第二层循环的时候，每次遇到还未找到的数字并且cnt还小于b[i]的时候，这个数字就一定是小于a[i]的，所以可以优化到双重循环。</p>

<h3 id="时间复杂度分析-5">时间复杂度分析：</h3>

<p>均为$O(N^2)$。</p>

<h3 id="期望得分-5">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码-5">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 105;
int a[N],b[N];
bool vis[N];

int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	char ch;
	scanf(&quot; %c&quot;,&amp;ch);
	if (ch == 'A')
	{
		getchar();
		getchar();
		for (int i = 0;i &lt; n;i++)
		{
			scanf(&quot;%d%c&quot;,&amp;a[i],&amp;ch);
		}
		b[0] = 0;
		for (int i = 1;i &lt; n;i++)
		{
			int cnt = 0;
			for (int j = 0;j &lt; i;j++)
			{
				if (a[j] &lt; a[i]) cnt++;
			}
			b[i] = cnt;
		}
		printf(&quot;B=(&quot;);
		for (int i = 0;i &lt; n;i++)
		{
			printf(&quot;%d%c&quot;,b[i],i == n - 1 ? ')' : ',');
		}
	}
	else
	{
		getchar();
		getchar();
		for (int i = 0;i &lt; n;i++)
		{
			scanf(&quot;%d%c&quot;,&amp;b[i],&amp;ch);
		}
		for (int i = n - 1;i &gt;= 0;i--)
		{
			int cnt = 0;
			for (int j = 0;j &lt; n;j++)
			{
				if (b[i] == cnt &amp;&amp; !vis[j])
				{
					vis[j] = 1;
					a[i] = j;
					break;
				}
				else if (!vis[j])
				{
					cnt++;
				}
			}
		}
		printf(&quot;A=(&quot;);
		for (int i = 0;i &lt; n;i++)
		{
			printf(&quot;%d%c&quot;,a[i],i == n - 1 ? ')' : ',');
		}
	}
	return 0;
}
</code></pre>

<h2 id="题目四-题目大意-1">题目四-题目大意</h2>

<p>一排上有$N$个格子，现在要在上面放若干个灯，相同颜色的灯必须连在一起，不同颜色的灯之间必须隔至少一个格子，问有多少种安排方案以及输出一个合理的安排方案（如果有）。</p>

<h2 id="考察算法-4">考察算法</h2>

<p>暴力枚举，深度优先搜索。</p>

<h2 id="算法一-4">算法一</h2>

<h3 id="思路-6">思路：</h3>

<p>首先不考虑颜色，用位运算，每次求出连续的1的段数是否和输入的颜色的个数相等并且数量一一对应相等。求出总的方案数之后再乘颜色的全排列，就是答案，在求合法方案的数的时候任意保存一个合法的方案即可。</p>

<h3 id="时间复杂度分析-6">时间复杂度分析：</h3>

<p>$O(N*2^N)$。</p>

<h3 id="期望得分-6">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码-6">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

int a[105];
char s[105][5];

long long fac(int n)
{
	long long ret = 1;
	for (int i = 1;i &lt;= n;i++)
	{
		ret *= i;
	}
	return ret;
}

int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	int cnt = 0;
	while (1)
	{
		scanf(&quot;%s&quot;,s[cnt]);
		if (s[cnt][0] == 'Q') break;
		int t;
		scanf(&quot;%d&quot;,&amp;t);
		a[cnt++] = t;
	}
	sort(a,a+cnt);
	int sum = (1 &lt;&lt; n);
	long long ans = 0;
	int ma = -1;
	for (int i = 0;i &lt; sum;i++)
	{
		vector&lt;int&gt; v,g;
		v.push_back(-1);
		for (int j = 0;j &lt; n;j++)
		{
			if (!(i &gt;&gt; j &amp; 1)) v.push_back(j);
		}
		v.push_back(n);
		for (int j = 0;j &lt; v.size() - 1;j++)
		{
			int x = v[j],y = v[j+1];
			int num = y - x - 1;
			if (num &lt;= 0) continue;
			g.push_back(num);
		}
		if (g.size() != cnt) continue;//连续的一的段数
		bool f = 0;
		for (int j = 0;j &lt; cnt;j++)
		{
			if (a[j] != g[j]) f = 1;//一一对应相等
		}
		if (!f)
		{
			ma = i;
			ans++;
		}
	}
	if (ma == -1) puts(&quot;0&quot;);
	else
	{
		ans *= fac(cnt);
		printf(&quot;%lld\n&quot;,ans);
		int k = 0;
		for (int i = 0;i &lt; n;i++)
		{
			if (ma &gt;&gt; i &amp; 1) printf(&quot;%c&quot;,s[k][0]);
			else
			{
				printf(&quot; &quot;);
				if (i != 0 &amp;&amp; (ma &gt;&gt; (i-1) &amp; 1)) k++;
			}
		}
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>

<h2 id="算法二-2">算法二</h2>

<h3 id="思路-7">思路：</h3>

<p>首先还是不管颜色的排列，用深度优先搜索，搜索出满足条件的方案总数，再乘颜色的全排列。如果有满足条件的方案，那么输出的方案就是每种颜色中间隔一个格子。</p>

<h3 id="时间复杂度分析-7">时间复杂度分析：</h3>

<p>$O(2^N)$。</p>

<h3 id="期望得分-7">期望得分：</h3>

<p>100分。</p>

<h3 id="参考代码-7">参考代码：</h3>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
using namespace std;

int n,sum,cnt;
char s[105][5];
int a[105];
long long ans;

long long fac(int n)
{
	long long ret = 1;
	for (int i = 1;i &lt;= n;i++)
	{
		ret *= i;
	}
	return ret;
}

//color_num是当前填的颜色，从0开始；pos是上一个放置的格子的位置；
//zero表示上一个格子是否放空格，1表示放
void dfs(int color_num,int pos,bool zero)
{
	if (color_num == cnt &amp;&amp; pos == n)
	{
		ans++;
		return;
	}
	if (pos &gt; n) return;
	if (zero) dfs(color_num + 1,pos + a[color_num],0);
	dfs(color_num,pos+1,1);
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	while (1)
	{
		scanf(&quot;%s&quot;,s[cnt]);
		if (s[cnt][0] == 'Q') break;
		int t;
		scanf(&quot;%d&quot;,&amp;t);
		a[cnt++] = t;
		sum += t;
	}
	dfs(0,0,1);
	if (!ans) puts(&quot;0&quot;);
	else
	{
		ans *= fac(cnt);
		printf(&quot;%lld\n&quot;,ans);
		for (int i = 0;i &lt; cnt;i++)
		{
			if (i != 0) printf(&quot; &quot;);
			for (int j = 0;j &lt; a[i];j++) printf(&quot;%c&quot;,s[i][0]); 
		}
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>

</article>



</div>
</div>
<script src="https://urlve.github.io//js/theme.min.js" type="text/javascript"></script>


</body>
</html>

